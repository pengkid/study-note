
## 散列概念

散列（Hash）是一种存储数据的方法。

散列中最关键的就是**散列函数**，它可以把要存储的数据（或者键值对中的“键”）映射为一个数值（散列值）。

## 散列表概览

散列表是基于散列而实现的一种数据结构。散列表的底层是通过一个数组，存储由散列函数生成的键值对（key-value），表示着一一对应的关系。

对应关系：

| 电话号       |  散列函数         |  散列值  |
|-------------|------------------|----------|
| 13844504465  |  func(){...}    |    num1    |
| 13844503592  |  func(){...}    |    num2    |
| 18800430403  |  func(){...}    |    num3    |

散列表：

| 键（key） |  值（value） |
|-------|-----------------|
| num1  |  13844504465    |
| num2  |  13844503592    | 
| num3  |  18800430403    | 


理论上，散列函数是会把每个键映射为数组中的唯一索引（地址），然而，键的数量是无限的，且数组的长度是有限的，因此会出现两个键映射为同一个索引的情况，这称之为**碰撞**。


## 实现散列表

HashTable类的构造函数如下：

```js
function hashTable(){
    this.table = new Array(137);   //底层数组，长度为一个较大的质数
    this.simpleHash = simpleHash;  //散列函数
    this.showDistro = showDistro;  //显示数据分布
    this.put = put;  //插入数据
    this.get = get;  //读取数据
}
```

### simpleHash：散列函数

最常用的散列方法就是**除留余数法**：对字符串中的每个字符进行求ASCII码值，然后所有ASCII码值求和后，以底层数组的长度对其取余。

在一些情况下，字符串的ASCII码值和为10的倍数，数组长度也为10，那么就会没有余数。这也是底层数组的长度要为质数的原因。

散列化字符串：
```js
var myArr = ["a","b","c"]

function simpleHash(str){
    var total = 0;
    const H = 37;
    for(var i=0, len=str.length; i<len; i++){
        total += ( total * H + str.charCodeAt(i) );
    }
    return total % this.table.length;
}


```

散列化数值：
```js
var myArr = [1,2,3]; 

function randomInt(arr){
    for(var i=0, len=arr.length; i<len; i++){
        var num ="";
        for(var i=0; i<9; i++){
            num += Math.floor( Math.random()*10 )
        }
        return num; 
    }
}

randomInt(myArr);
```

为了有效的避免碰撞，我们采用**霍纳算法**，在每次求和ASCII码前都先乘以一个质数（H）。

### showDistro：显示数据分布

```js
function showDistro(){
    for(var i=0, len=this.table.length; i<len; i++){
        if(this.table[i] != undefined){
            console.log(i+": "+this.table[i]);
        }
    }
}
```


### put：存储数据

存储**数据**的散列表：
```js
function put(key){
    var pos = this.simpleHash(key);
    this.table[pos] = key;
}
```

存储**键值对**的散列表：
```js
function put(key, value){
    var pos = this.simpleHash(key);
    this.table[pos] = value;
}
```

事实上，在实际场景中，我们大多的情况都是采用第二种`put`方法——存储键值对。


### get：获取数据

`get`方法只有在存储的数据为键值对的情况下才有意义，因为获取数据都是通过散列值（即数组中的索引）。

```js
function get(key){
    var pos = this.simpleHash(key);
    return this.table[pos];
}
```


## 碰撞处理

### 开链法



### 线性探测法



