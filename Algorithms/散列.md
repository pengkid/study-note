
## 散列概念

散列（Hash）是一种存储数据的方法。

散列中最关键的就是**散列函数**，它可以把要存储的数据（或者键值对中的“键”）映射为一个数值（散列值）。

## 散列表概览

散列表是基于散列而实现的一种数据结构。散列表的底层是通过一个数组，存储由散列函数生成的键值对（key-value）。

如下表：

| 电话号       |  散列函数         |  散列值  |  散列表    |
|-------------|-----------------|----------|-----------|
| 13844504465  |  func(){...}    |    50    |           |
| 13844503592  |  func(){...}    |    60    |           |
| 18800430403  |  func(){...}    |    70    |           |


理论上，散列函数是会把每个键映射为数组中的唯一索引（地址），然而，键的数量是无限的，且数组的长度是有限的，因此会出现两个键映射为同一个索引的情况，这称之为**碰撞**。


## 实现散列表



```js
function hashTable(){
    this.table = new Array(137);   //存储数据，数组长度为一个较大的质数
    this.simpleHash = simpleHash;  //散列函数
    this.showDistro = showDistro;  //显示数据分布
    this.put = put;  //插入数据
    this.get = get;  //读取数据
}
```


### simpleHash：散列函数

最常用的散列方法就是**除留余数法**：对字符串中的每个字符进行求ASCII码值，然后所有ASCII码值求和后，对底层数组的长度求余数。

比如，字符串的ASCII和为10的倍数，数组长度也为10的倍数，那么没有余数。这也是我们的底层数组的长度为质数的原因。

```js
function simpleHash(str){
    var total = 0;
    const H = 37;
    for(var i=0, len=str.length; i<len; i++){
        total += ( total * H + str.charCodeAt(i) );
    }
    return total % this.table.length;
}
```

为了有效的避免碰撞，我们采用**霍纳算法**，在每次求和前都先乘一个质数（H）。

### showDistro：显示数据分布

```js
function showDistro(){
    for(var i=0, len=this.table.length; i<len; i++){
        if(this.table[i] != undefined){
            console.log(i+": "+this.table[i]);
        }
    }
}
```


### put：存储数据

存储**数据**的散列表：
```js
function put(key){
    var pos = this.simpleHash(key);
    this.table[pos] = key;
}
```

存储**键值对**的散列表：
```js
function put(key, value){
    var pos = this.simpleHash(key);
    this.table[pos] = value;
}
```

事实上，在实际场景中，我们大多的情况都是采用第二种`put`方法——存储键值对。


### get：获取数据

`get`方法只有在存储的数据为键值对的情况下才有意义，因为获取数据都是通过散列值（即数组中的索引）。

```js
function get(key){
    var pos = this.simpleHash(key);
    return this.table[pos];
}
```



## 碰撞的常用解决方法




