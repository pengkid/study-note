
## 基本排序

基本排序的算法思想是指对一组数据按照一定的顺序进行排列。在排序的时候用的一般都是一组嵌套循环，外层循环遍历数组元素，内层循环比较元素。

### 冒泡排序

算法思想：

1. 外层循环获取当前数组元素，并且挨个移动数组元素

2. 内层循环遍历当前元素后面所有的元素，如果比当前元素大，则元素位置互换

3. 当外层循环执行到倒数第二个位置时，所有数组已经完成了排序

```js
function bubbleSort(arr){
    for(var i=0, len1=arr.length-1; i<len1; i++){
        for(var j=i+1, len2=arr.length; j<len2; j++){
            if(arr[i]>arr[j]){
                let temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
    return arr;
}
```

> 冒泡排序是速度最慢，但最容易实现的一种排序算法。

### 选择排序

算法思想：

1. 从数组开头开始，将第一个元素和后面所有元素比较，找出最小元素放到数组的第一个位置

2. 从数组第二个位置继续，重复步骤1，如此类推

```js
function selectionSort(arr){
    var len = arr.length;
    var min, temp;
    for(var i=0; i<len-1; i++){
        min = i;
        for(var j=i+1; j<len; j++){
            if(arr[j] < arr[min]) min = j;
        }
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
    return arr;
}
```

### 插入排序

算法思想：

1. 外层循环获取当前数组元素，并且挨个移动数组元素

2. 内循环遍历当前元素前面的元素，如果内循环选中的元素大于当前元素，那么内循环的元素向右移动，直到内层选中的元素小于外层选中的元素

3. 内循环结束后，往空位置插入外循环的当前元素

```js
function insertionSort(arr){
    for(var i=1, len=arr.length; i<len; i++){
        let temp = arr[i];
        let index = i;
        while(index>0 && arr[index-1]>=temp){
            arr[index] = arr[index-1];
            index--;
        }
        arr[index] = temp;
    }
    return arr;
}
```

> 插入排序与冒泡排序不同，冒泡排序强调的是数据交换，而插入排序是通过将较大元素往数组右边移动，为数组左边的较小元素腾出空位。

## 高级排序

### 快速排序

算法思想：

1. 取数组中的一个元素为键（通常是数组首元素）

2. 遍历数组中的元素（从第二个位置开始），比键小的元素推入到左数组，比键大的元素推入到右数组

3. 对左数组和右数组均递归调用排序函数


```js
function quickSort(arr){
    if(arr.length<=1){ return arr }        
    
    var left  = [];
    var right = [];
    var key = arr[0];
    
    for(var i=1, len=arr.length; i<len; i++){
        if(arr[i]<key){
            left.push(arr[i]);
        }
        else{
            right.push(arr[i]);
        }
    }
    
    return [].concat(quickSort(left),key,quickSort(right));
}
```

### 希尔排序

算法思想：

1. 把数据集按步长（gap）进行分组，对每组记录进行插入排序（远距离比较）

2. 当所有组的插入排序结束后，步长按照某种规律递减（动态间距或硬编码间距），并循环执行步骤1，直到步长<1，跳出循环

3. 随着步长逐渐减少，所分成的组包含的数据越来越多，当步长为1时，数据合成一组，则完成排序

```js
function shellSort(arr){
    var len = arr.length;
    var gap = Math.floor(len / 2);
    while(1<=gap){
        // 按照gap对数据集进行分组，并且遍历所有的组
        for(var i=gap; i<len; i++){
            var temp = arr[i];
            // 对分组进行远距离的插入排序
            for(var j=i-gap; j>=0 && arr[j]>temp ;j=j-gap){
                arr[j + gap] = arr[j];;
            }
            arr[j + gap] = temp;
        }
        console.log(arr+" 步长为："+gap);
        gap = Math.floor(gap/2);
    }
    return arr;
}
```

> 希尔排序的核心在于设置一个间距序列，而希尔排序算法创始人提倡使用 (N/2) 作为步长，其中 N 为数组长度。

#### 动态间距的希尔排序

事实上，在经典的希尔排序中，我们采用了动态的间距，即间距不是提前好决定的，而是每次循环后都通过某种公式运算得到的，并不是人为事先确定。

```js
function shellSort(arr){
    var H = arr.length;
    var h = 1;
    while(h < H/3){
        h = 3*h+1;
    }
    while(1<=h){
        for(var i=h; i<H; i++){
            var temp = arr[i];
            for(var j=i-h; j>=0 && arr[j]>temp ;j=j-h){
                arr[j+h] = arr[j];
            }
            arr[j+h] = temp;
        }
        console.log(arr+" 步长为："+h);
        h = (h-1)/3;
    }
    return arr;
}
```

> 这是由 Sedgewick 提出的一个新的步长函数

#### 硬编码的希尔排序


```js
var gaps = [109, 41, 19, 5, 1];

function shellSort(arr){
    for(var i=0, len1=gaps.length; i<len1; i++){
        for(var )
    }
}
```

> 同一种递减间距，无论是硬编码间距，还是动态间距，效率都是一样的。

### 归并排序

算法思想：


```js
function (){

} 
```
