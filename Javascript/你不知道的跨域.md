## 同源策略

一个域名下的文件去请求了和它不一样的域名下的资源文件，那么就会产生跨域请求。

简单说来，只有当协议，主域名，子域名，端口都相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

|      URL    |     说明   |  是否允许通信   |
|------------|-------------|-------------|
| `http://www.a.com/a.js`<br /> `http://www.a.com/b.js`  |  同一域名   | 允许 |
| `http://www.a.com/a.js`<br /> `http://www.b.com/b.js`   |  不同域名  | 不允许 |
| `http://www.a.com:80/a.js`<br /> `http://www.a.com:90/b.js`  | 同一域名不同端口 | 不允许 |
| `http://www.a.com/a.js`<br /> `http://a.com/b.js`   |  相同主域名，不同子域名  |  不允许 |
|`http://www.a.com/a.js`<br /> `https://www.a.com/b.js` | 不同协议名 | 不允许|

**浏览器出于对安全方面的考虑，不允许跨域调用其他页面的数据。**

## JSONP

可以通过后端请求，解决同源策略这个问题（PHP、Nodejs等不受限制）。

这个主要是利用了`<script>`标签的src，有点bug的味道在里面。因为这个属性不仅可以链接到同一个服务器里的相对路径，还可以外链其他域名下的JS文件。比如说，接口文件在北京服务器，而AJAX方法写在了广州服务器，我要实现跨域的话，在广州服务器的脚本文件里面写一个`<script>`，src属性是指向北京服务器的api地址，并且再写一个回调函数来接受服务端数据，从而实现间接调用北京服务器的接口。正常做的话，都是直接用JQuery封装好的方法，把dataType设成JSONP，加一个jsonp属性，就可以实现跨域了。但正因为是个url外链的形式，所以JSONP只能对GET请求有效，对POST是不起作用的。


首先在js文件创建一个函数fn()，然后后端返回一个包含参数的执行函数，函数就会自动运行。
```js
//Js文件
<script>
    function fn(data) {
        console.log(data)
    }
</script>
<script src="2.js"></script>


//后端返回，以PHP为例

$arr1 = array('111111','22222222','33333333','4444444','555555555555555555555');
echo 'fn('.json_encode($arr1).')'
为防止页面加载就运行，可以使用动态添加script标签，然后才会运行。

oBtn1.onclick = function() {
    var oScript = document.createElement('script');
    oScript.src = 'getData.php';
    document.body.appendChild(oScript);
}
```

