## 同源策略

一个域名下的文件去请求了和它不一样的域名下的资源文件，那么就会产生跨域请求。

简单说来，只有当协议，主域名，子域名，端口都相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

|      URL    |     说明   |  是否允许通信   |
|------------|-------------|-------------|
| `http://www.a.com/a.js`<br /> `http://www.a.com/b.js`  |  同一域名   | 允许 |
| `http://www.a.com/a.js`<br /> `http://www.b.com/b.js`   |  不同域名  | 不允许 |
| `http://www.a.com:80/a.js`<br /> `http://www.a.com:90/b.js`  | 同一域名不同端口 | 不允许 |
| `http://www.a.com/a.js`<br /> `http://a.com/b.js`   |  相同主域名，不同子域名  |  不允许 |
|`http://www.a.com/a.js`<br /> `https://www.a.com/b.js` | 不同协议名 | 不允许|

**浏览器出于对安全方面的考虑，不允许跨域调用其他页面的数据。**

## JSONP

页面上调用 js 文件不受浏览器同源策略的影响，不仅可以链接到同一个服务器里的相对路径，还可以外链其他域名下的JS文件，所以通过 `<script>` 标签进行跨域的请求。


首先在js文件创建一个函数foo()，然后后端返回一个包含参数的执行函数，函数就会自动运行。

```js
//前端代码
<script>
    function foo(data) {
        console.log(data);
    }
</script>
<script src="data.js"></script>


//为防止页面加载就运行，可以使用动态添加script标签，然后才会运行。
oBtn1.onclick = function() {
    var oScript = document.createElement('script');
    oScript.src = 'getData.php';
    document.body.appendChild(oScript);
}


//后端逻辑
const url = require('url');

require('http').createServer((req, res) => {
    const data = {
        x: 10
    };
    
    const callback = url.parse(req.url, true).query.callback;
    res.writeHead(200);
    res.end(`${callback}(${JSON.stringify(data)})`);
    
}).listen(3000, '127.0.0.1');
```

