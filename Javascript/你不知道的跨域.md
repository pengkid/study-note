## 同源策略

一个域名下的文件去请求了和它不一样的域名下的资源文件，那么就会产生跨域请求。

简单说来，只有当协议，主域名，子域名，端口都相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

|      URL    |     说明   |  是否允许通信   |
|------------|-------------|-------------|
| `http://www.a.com/a.js`<br /> `http://www.a.com/b.js`  |  同一域名   | 允许 |
| `http://www.a.com/a.js`<br /> `http://www.b.com/b.js`   |  不同域名  | 不允许 |
| `http://www.a.com:80/a.js`<br /> `http://www.a.com:90/b.js`  | 同一域名不同端口 | 不允许 |
| `http://www.a.com/a.js`<br /> `http://a.com/b.js`   |  相同主域名，不同子域名  |  不允许 |
|`http://www.a.com/a.js`<br /> `https://www.a.com/b.js` | 不同协议名 | 不允许|

**浏览器出于对安全方面的考虑，不允许跨域调用其他页面的数据。**


## JSONP


可以通过后端请求，解决这个问题。PHP、Nodejs等不受限制。

首先在js文件创建一个函数fn()，然后后端返回一个包含参数的执行函数，函数就会自动运行。
```js
//Js文件
<script>
function fn(data) {
    console.log(data)
}
</script>
<script src="2.js"></script>


//后端返回，以PHP为例

$arr1 = array('111111','22222222','33333333','4444444','555555555555555555555');
echo 'fn('.json_encode($arr1).')'
为防止页面加载就运行，可以使用动态添加script标签，然后才会运行。

oBtn1.onclick = function() {
    var oScript = document.createElement('script');
    oScript.src = 'getData.php';
    document.body.appendChild(oScript);
}
```

