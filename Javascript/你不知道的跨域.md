## 同源策略

一个域名下的文件去请求了和它不一样的域名下的资源文件，那么就会产生跨域请求。

简单说来，只有当协议，主域名，子域名，端口都相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

|      URL    |     说明   |  是否允许通信   |
|------------|-------------|-------------|
| `http://www.a.com/a.js`<br /> `http://www.a.com/b.js`  |  同一域名   | 允许 |
| `http://www.a.com/a.js`<br /> `http://www.b.com/b.js`   |  不同域名  | 不允许 |
| `http://www.a.com:80/a.js`<br /> `http://www.a.com:90/b.js`  | 同一域名不同端口 | 不允许 |
| `http://www.a.com/a.js`<br /> `http://a.com/a.js`   |  相同主域名，不同子域名  |  不允许 |
|`http://www.a.com/a.js`<br /> `https://www.a.com/b.js` | 不同协议名 | 不允许|

**浏览器出于对安全方面的考虑，不允许跨域调用其他页面的数据。**

## JSONP

最广为流传的跨域方法就是：**JSONP** 。

页面上调用 js 文件是不受浏览器同源策略的影响，不仅可以请求同一服务器里的文件，还可以请求其他域名下的文件，所以可以通过 `script` 标签进行跨域请求资源：

1. 在js文件创建一个回调函数（函数名提前约定或以参数传递）

2. 后端接收到请求后，返回一个包含参数的回调函数，函数就会自动运行

前端代码：
```html
<script>
    function foo(data) {
        console.log(data.x);
    }
</script>
<script src="127.0.0.1:4000?callback=foo"></script>


//为防止页面加载就运行，可以使用动态添加script标签，然后才会运行。
btn.onclick = function() {
    var oScript = document.createElement('script');
    oScript.src = '127.0.0.1:4000?callback=foo';
    document.body.appendChild(oScript);
}
```

后端逻辑：
```js
//server.js文件

const url = require('url');
const http = require('http');

http.createServer((req, res) => {
    const data = {
        x: 10
    };
    
    const callback = url.parse(req.url, true).query.callback;
    res.writeHead(200);
    res.end(`${callback}(${JSON.stringify(data)})`);
    
}).listen(4000, '127.0.0.1');

console.log("启动服务, 监听 127.0.0.1:4000 ")
```

至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种方式也存在着一定的优缺点：

* 优点

  * 它不像 XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制
  
  * 兼容性很好，在古老的浏览器也能很好的运行


* 缺点

  * 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。
  
  * 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题


## CORS

CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 `XMLHttpRequest` 请求，从而克服了 ajax 只能同源使用的限制。

CORS 需要浏览器和服务器同时支持才可以生效，对于前端来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。


后端逻辑：

```js
const = require('http');

http.createServer((req, res) => {

    res.writeHead(200, {
        'Access-Control-Allow-Origin': 'http://127.0.0.1:8080'
    });
    res.end('这是你要的数据：10');

}).listen(4000, '127.0.0.1');

console.log('启动服务，监听 127.0.0.1:4000');
```

关键是在于设置响应头中的 `Access-Control-Allow-Origin`，该值要与请求头中 Origin（请求页面的域名）一致才能生效，否则将跨域失败，浏览器将认为这是一次失败的异步请求，将会调用 `xhr.onerror` 中的函数。

CORS 的优缺点：

* 使用简单方便，更为安全

* 支持 POST 请求方式

* CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上


## location.hash




