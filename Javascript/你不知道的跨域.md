## 同源策略

一个域名下的文件去请求了和它不一样的域名下的资源文件，那么就会产生跨域请求。

简单说来，只有当协议，主域名，子域名，端口都相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

|      URL    |     说明   |  是否允许通信   |
|------------|-------------|-------------|
| `http://www.a.com/a.js`<br /> `http://www.a.com/b.js`  |  同一域名   | 允许 |
| `http://www.a.com/a.js`<br /> `http://www.b.com/b.js`   |  不同域名  | 不允许 |
| `http://www.a.com:80/a.js`<br /> `http://www.a.com:90/b.js`  | 同一域名不同端口 | 不允许 |
| `http://www.a.com/a.js`<br /> `http://a.com/b.js`   |  相同主域名，不同子域名  |  不允许 |
|`http://www.a.com/a.js`<br /> `https://www.a.com/b.js` | 不同协议名 | 不允许|

**浏览器出于对安全方面的考虑，不允许跨域调用其他页面的数据。**

## JSONP

最广为流传的跨域方法就是：JSONP 。

页面上调用 js 文件不受浏览器同源策略的影响，不仅可以链接到同一个服务器里的文件，还可以外链其他域名下的文件，所以通过 `<script>` 标签进行跨域请求。

首先在js文件创建一个回调函数（函数名提前约定或以参数传递），然后后端返回一个包含参数的回调函数，函数就会自动运行。

前端代码：
```js
<script>
    function foo(data) {
        console.log(data);
    }
</script>
<script src="data.js"></script>


//为防止页面加载就运行，可以使用动态添加script标签，然后才会运行。
Btn1.onclick = function() {
    var oScript = document.createElement('script');
    oScript.src = 'data.js';
    document.body.appendChild(oScript);
}
```

后端逻辑：
```js
const url = require('url');

require('http').createServer((req, res) => {
    const data = {
        x: 10
    };
    
    const callback = url.parse(req.url, true).query.callback;
    res.writeHead(200);
    res.end(`${callback}(${JSON.stringify(data)})`);
    
}).listen(4000, '127.0.0.1');
```

至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种事方式也存在着一定的优缺点：

* 优点

  * 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制
  
  * 兼容性很好，在古老的浏览器也能很好的运行
  
  * 不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。

* 缺点

  * 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。
  
  * 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题
  

## CORS

