
闭包：
	函数是创建作用域的唯一方法
	
	闭包：函数调用时该函数能够访问其他函数作用域内的变量的一种特殊状态
	
	闭包因保存函数而被创建：函数能够访问当前执行环境的变量，并且函数最后保存在执行环境之外的变量中

	闭包内的变量和参数，在函数或者闭包执行完毕后，不会被垃圾回收器回收，即长期保存在内存中
	（这是为了要保证内部函数执行时，能够成功访问执行环境内的变量，而不是永恒返回 undefined ）
	
	好处：
		1.希望将一个变量长期保存在内存之中，不被垃圾回收机制回收
		function a(){
			let a = 10;
			return function b(){
				console.log(a);
				a++;
			}
		}
		var b = a();	// b指向内部函数b()，创建一个闭包
		b();			// 10，触发了闭包
		b();			// 11，触发了闭包
	
		2.避免污染全局变量
		var a = 10;
		var b = function(i){
			return function(){
				console.log(i);
				i++;
			}
		}(a);
		b();	// 10
		b();	// 11
		console.log(a)	// 10

		3.创建私有成员
		var test = function(){
			let a = 10;
			function member1(){
				console.log(++a);
			};
			function member2(){
				console.log(--a);
			}
			return {member1:member1, member2:member2}
		}
		var b = test();
		console.log(b);
		b.member1();	// 11
		b.member2();	// 10

	坏处：
		1.内存泄漏
		window.onload = function(){
			var btn = document.getElementById('btn');
			btn.onclick = function(){
				// 代码
			}
		}
		这也是一个闭包，在触发点击事件后，事件得不到释放，影响CPU性能，导致内存泄漏
		可以在点击之后添加 btn.click = null

IIFE，立即执行函数(function(){…})()，(function(){…}())
	在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符
	都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这
	是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数。加括号是最安全的做法，因为！、+、-等
	运算符还会和函数的返回值进行运算，有时造成不必要的麻烦

	IIFE，立即执行函数，其实就是一个函数表达式，外围的()只是单纯的表示这是一个函数表达式，没有其他意思

	如果用函数声明符function声明函数，但却是匿名的除非把匿名函数赋给变量作为函数表达式
	或赋给事件作为事件处理机制，或嵌套在函数内作为闭包，否则报错
	
	IIFE最大的作用就是创建命名空间，或者说一个模块模式。该区块内的属性方法不会跟外部的同名变量方法所冲突
	同时函数内的变量方法可以很容易的相互访问，而外部只能通过区块暴露接口的形式来访问 ： 内部函数 return 
	某个属性或者方法给外部的变量。注意，一旦 return 的是方法而且是有变量访问的方法，那么闭包就创建了


	IIFE配合闭包：
	var items = document.getElementsByTagName("li");
    for(var i=0; i<items.length; i++){
        (function foo(i){
            items[i].onclick = function(){
                console.log(i); 
                //这个的意思依旧是那样：给元素对象事件赋值一个匿名函数作为事件处理机制.但是匿名函数作为内部函数（闭包），它有权访问外部函数的参数和变量，也就是说匿名函数的 i 是外部函数传进来的参数
            }
        })(i);
    }
